const connectMongo = require('../connections/mongo');const {loadConfig} = require('../functions');const {TextDecoder, TextEncoder} = require('text-encoding');const {Api, JsonRpc} = require('eosjs');const fetch = require('node-fetch');const MongoLong = require('mongodb').Long;const config = loadConfig();const eosTableAtBlock = require('../eos-table');class WorkerProposalsHandler {    constructor() {        this.config = loadConfig();        this.db = connectMongo(config);        this.proposals_contract = config.eos.proposalsContract || 'dacproposals';        const rpc = new JsonRpc(this.config.eos.endpoint, {fetch});        this.api = new Api({            rpc,            signatureProvider: null,            chainId: this.config.chainId,            textDecoder: new TextDecoder(),            textEncoder: new TextEncoder(),        });    }    async replay() {        const mongo = await this.db;        const db = mongo.db(this.config.mongo.dbName);        const collection = db.collection('workerproposals');        const collection_actions = db.collection('actions');        collection.createIndex({id:1, dac_scope:1, block_num:1}, {background:true, unique:true});        console.log('Removing existing entries');        await collection.deleteMany({});        const res = collection_actions.find({            'action.account': this.proposals_contract,            'action.name': 'createprop'        }).sort({block_num: 1});        let doc;        let count = 0;        console.log((await res.count()) + ' proposals found');        while (doc = await res.next()) {            await this.recalcProposal(doc);            count++        }        console.log(`Imported ${count} worker proposals`);        // process.exit(0)    }    async recalcProposal(doc) {        console.log('Recalc', doc);        const mongo = await this.db;        const db = mongo.db(this.config.mongo.dbName);        const coll = db.collection('workerproposals');        const coll_actions = db.collection('actions');        const data = doc.action.data;        if (!data.id){            // Old format            return;        }        // if this is not the createprop action, then find it        if (doc.action.name !== 'createprop'){            console.log('Finding createprop action');            doc = coll_actions.findOne({                "action.account":this.proposals_contract,                "action.name": 'createprop',                "action.data.proposal_id": data.id,                "action.data.dac_scope": data.dac_scope,                "block_num": {$lte: doc.block_num}            });        }        // Find the closing actions to get the range for this proposal        // this is in case there are more than one proposal with the same id        const closing_actions = ['arbapprove', 'finalize', 'cancel'];        const closing_res = coll_actions.find({            "action.account":this.proposals_contract,            "action.name": {$in:closing_actions},            "action.data.proposal_id": data.id,            "action.data.dac_scope": data.dac_scope,            "block_num": {$gte: doc.block_num}        });        // get votes and updates between start and end block        const is_closed = (await closing_res.count() > 0);        console.log(`Is closed ${is_closed}`);        const data_query = {            key: data.id        };        // get current status from the table        const table_query = {            code: this.proposals_contract,            table: 'proposals',            scope: data.dac_scope,            db,            data_query        };        let closing_block_num = 0;        if (is_closed){            closing_block_num = (await closing_res.next()).block_num;            table_query.block_num = closing_block_num;        }        const table_res = await eosTableAtBlock(table_query);        if (!table_res.count){            console.error(`Could not find state for proposal ${data.id}`);        }        data.status = table_res.results[0].data.state;        data.block_timestamp = doc.block_timestamp;        data.trx_id = doc.trx_id;        // Get votes        const cat_delegates_query = {            code: this.proposals_contract,            table: 'catvotes',            scope: data.dac_scope,            db,            limit: 100        };        if (closing_block_num){            cat_delegates_query.block_num = closing_block_num;        }        const cat_delegates_res = await eosTableAtBlock(cat_delegates_query);        const indexed_cat_delegates = {};        for (let c=0;c<cat_delegates_res.results.length;c++){            console.log(cat_delegates_res.results[c].data);            const data = cat_delegates_res.results[c].data;            if (typeof indexed_cat_delegates[data.category_id] === 'undefined'){                indexed_cat_delegates[data.category_id] = {};            }            if (typeof indexed_cat_delegates[data.category_id][data.voter] === 'undefined'){                indexed_cat_delegates[data.category_id][data.delegatee] = [];            }            indexed_cat_delegates[data.category_id][data.delegatee].push(data.voter);        }        const votes_query = {            code: this.proposals_contract,            table: 'propvotes',            scope: data.dac_scope,            db        };        if (closing_block_num){            votes_query.block_num = closing_block_num;        }        const votes_res = await eosTableAtBlock(votes_query);        const votes_data = [];        for (let v=0;v<votes_res.results.length;v++){            const vote_data = votes_res.results[v].data;            delete vote_data.proposal_id;            if (typeof indexed_cat_delegates[data.category_id] !== 'undefined' &&                typeof indexed_cat_delegates[data.category_id][vote_data.voter] !== 'undefined'){                console.log(`Adding delegates (TODO)`, indexed_cat_delegates[data.category_id][vote_data.voter]);            }            votes_data.push(vote_data);        }        data.votes = votes_data;        data.id = MongoLong.fromString(data.id);        data.block_num = doc.block_num;        coll.updateOne({id: data.id}, {$set:data}, {upsert:true});    }    async action(doc) {        if (doc.action.account === this.proposals_contract){            console.log('Reacting to proposals action');            this.recalcProposal(doc);        }    }}module.exports = new WorkerProposalsHandler();